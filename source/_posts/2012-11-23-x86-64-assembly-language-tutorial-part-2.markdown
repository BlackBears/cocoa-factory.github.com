---
layout: post
title: "x86_64 Assembly Language Tutorial: Part 2"
date: 2012-11-23 05:34
comments: false
categories: x86_64 assembler tutorial macos
---

In our [last installment](http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/) of our x86_64 assembler tutorial, we introduced the registers and walked through a simple C program and its assembly langugage counterpart.  This time, we'll talk a little more about the effect of optimizations and while we're at it, present some of the highlights of the application binary interface, the ABI.

Let's start with our original code that we [presented last time](http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/):

{% gist 4135115 %}

### Optimization setting - -O, O1 ###

{% img left http://i.imgur.com/O9LQR.png 'Figure 1: Optimization setting' %}
This time, we're going to set the optimizations differently to see what effect it has on the code.  Recall that we ran with no optimizations the first time.  If you want to follow along in Xcode, then just create a command-line application project and search for 'optimization' in the target build settings.  

{% img right http://i.imgur.com/NcgDW.png 'Figure 2: Disassembly assistant setting' %}
Paste the code above into `main.m` to replace the code that's autogenerated by the template; and place a breakpoint on the return line.  We won't be able to see the disassembly code unless the application is actually running; so we want to break somewhere accordingly.  We can view either the assembly or disassembly code.  We're going to look at the former because the latter contains a lot of debugging symbols that make it harder to understand what we're really interested in - the instructions.  To show the disassembly results, build and run the project.  When the debugger stops on the return line, show the Assistant editor which splits the main viewer into two panes.  In the right pane, select Disassembly as the assistant pane content.  If you're not with me, then you may want to take a while to get familiar with the Xcode 4.x interface so that you can configure it the way you want.

### Disassembler code ###

The disassembler takes the machine code that your C code generated and expresses it symbolically in assembly langugage.  Let's take a look at the results and compare it to the results from the [last tutorial](http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/).

{% gist 4135317 %}

### Step-by-step ###

And just like we did before, let's look at the code step-by-step.  This time we're going to compare it to the code with no optimizations from last time, so you may want to be familiar with it first.

#### Step 1 - Preamble ####

``` c-objdump
0x100000ee0:  pushq  %rbp
0x100000ee1:  movq   %rsp, %rbp
```

This is the same function preamble as before, saving the current base pointer and moving the stack pointer to the base pointer register.

#### Step 2 - Save the registers ####

``` c-objdump
0x100000ee4:  pushq  %r15
0x100000ee6:  pushq  %r14
0x100000ee8:  pushq  %rbx
0x100000ee9:  pushq  %rax
```

We push several 64-bit registers to the stack.  We don't know yet; but probably this is because we're going to use them later on.  Let's see what's next.

#### Step 3 - Start the autorelease pool ####

``` c-objdump
0x100000eea:  callq  0x100000f2e               ; symbol stub for: objc_autoreleasePoolPush
0x100000eef:  movq   %rax, %r14
```

Set up the autorelease pool for the function as before.  This time, we're saving the return value - a reference to the autorelease pool, presumably - to `%r14`.  We'll set it again later before we pop the autorelease pool.  But before we do, it's a good time to present some of the register allocations from the [x86_64 ABI](http://www.x86-64.org/documentation/abi.pdf).  The ABI exists to create some standardization in the way that assembly code interacts with the machine.  Part of that specification are standards that determine which registers are used for a given purpose.  We'll present them here:

Register  | Usage                                                           | Preserved across function calls
--------- | --------------------------------------------------------------- | -------------------------------
`%rax`    | 1st return register, number of vector registers used            | No
`%rbx`    | callee-saved register; base pointer                             | Yes
`%rcx`    | pass 4th integer argument to functions                          | No
`%rdx`    | pass 3rd argument fo functions, 2nd return register             | No
`%rsp`    | stack pointer                                                   | Yes
`%rbp`    | callee-saved register, frame pointer                            | Yes
`%rsi`    | used to pass 2nd argument to functions                          | No
`%rdi`    | used to pass 1st argument to functions                          | No
`%r8`     | used to pass 5th argunent to functions                          | No
`%r9`     | used to pass 6th argument to functions                          | No
`%r10`    | temp register, used for passing a function's static chain ptr   | No
`%r11`    | temp register                                                   | No
`%r12`    | callee-saved register                                           | Yes
`%r13`    | callee-saved register                                           | Yes
`%r14`    | callee-saved register                                           | Yes
`%r15`    | callee-saved register                                           | Yes
`%xmm0`   | used to pass and return floating point arguments                | No
`%xmm1`   | used to pass and return floating point arguments                | No
`%xmm2`   | used to pass floating point arguments                           | No
`%xmm3`   | used to pass floating point arguments                           | No
`%xmm4`   | used to pass floating point arguments                           | No
`%xmm5`   | used to pass floating point arguments                           | No
`%xmm6`   | used to pass floating point arguments                           | No
`%xmm7`   | used to pass floating point arguments                           | No
`%xmm8`   | temporary register                                              | No
`%xmm9`   | temporary register                                              | No
`%xmm10`  | temporary register                                              | No
`%xmm11`  | temporary register                                              | No
`%xmm12`  | temporary register                                              | No
`%xmm13`  | temporary register                                              | No
`%xmm14`  | temporary register                                              | No
`%xmm15`  | temporary register                                              | No
`%mmx0`   | temporary register                                              | No
`%mmx1`   | temporary register                                              | No
`%mmx2`   | temporary register                                              | No
`%mmx3`   | temporary register                                              | No
`%mmx4`   | temporary register                                              | No
`%mmx5`   | temporary register                                              | No
`%mmx6`   | temporary register                                              | No
`%mmx7`   | temporary register                                              | No
`%st0`    | temporary register, used to return long double arguments        | No
`%st1`    | temporary register, used to return long double arguments        | No
`%st2`    | temporary register                                              | No
`%st3`    | temporary register                                              | No
`%st4`    | temporary register                                              | No
`%st5`    | temporary register                                              | No
`%st6`    | temporary register                                              | No
`%st7`    | temporary register                                              | No

Whew! Got that memorized yet?  Oh well, let's move on.

#### Step 4 - Idiom for clearing register ####

``` c-objdump
0x100000ef2:  xorl   %ebx, %ebx
```

This is a curious instruction, XOR long `%ebx` with itself.  Self-XOR has the effect of clearing the register which on some processors is faster than `movl $0, %ebx`.  If we're setting something to zero, I wonder if the compiler is using `%ebx` as the loop index.  We shall see...

#### Step 5 - Obtain format string address

``` c-objdump
0x100000ef4:  leaq   111(%rip), %r15           ; "i = %d\n"
```

This instruction reads "load effective address 64-bit into `%15`".  We're just grabbing the format string from a particular location in memory relative to the instruction pointer.

#### Step 6 - Alignment  ####

``` c-objdump
0x100000efb:  nopl   (%rax,%rax)
```

This is an optimization that does nothing other than align the code properly for the jump target so that it can be fetched in a single cacheline request.

#### Step 7 - Setting up call to `printf` ####

``` c-objdump
0x100000f00:  movq   %r15, %rdi
0x100000f03:  movl   %ebx, %esi
0x100000f05:  xorb   %al, %al
0x100000f07:  callq  0x100000f34               ; symbol stub for: printf
```

Remember from the ABI register usage table above that `%rdi` is used to pass the first argument to functions.  In this case, the format string is the first argument of `printf`.  Earlier in Step 5, we loaded the address of the string into `%r15`; now we're moving it to `%rdi` in preparation for the `printf` function call.  Next, `movl   %ebx, %esi` - remember earlier we wondered if the compiler was using `%esi` as the loop index?  From the reference table above, `%rsi` is used to pass the second function parameter; so this instruction passes the second parameter which is the loop index `i` in the C code.  

`xorb   %al, %al` clears the `%al` register which is the lowest 8 bits of `%rax` which is the register that passes the number of vector arguments.  As in the prior tutorial, since we are printing an integer, we don't need a vector register.  Hence, we clear `%al`.

#### Step 8 - Increment, compare, and jump ####

``` c-objdump
0x100000f0c:  incl   %ebx
0x100000f0e:  cmpb   $16, %bl
0x100000f11:  jne    0x100000f00               ; main + 32 at main.m:17
```

In order, we increment the register we're using for the loop index, compare its lower 8 bits to decimal 16 with a byte compare instruction and jump if not equal back to Step 7.

#### Step 9 - Pop the autorelease pool ####

``` c-objdump
0x100000f13:  movq   %r14, %rdi
0x100000f16:  callq  0x100000f28               ; symbol stub for: objc_autoreleasePoolPop
```

Recall that in Step 3 we saved a reference to the autorelease pool in `%r14`?  Now we move that reference back to `%rdi` which is used to pass the first argument to functions. (Is this sounding like a broken record now?)  Then we call objc_autoreleasePoolPop in the Objective-C runtime to release the autorelease pool.

#### Step 10 - Setting up to return ####

```  c-objdump
0x100000f1b:  xorl   %eax, %eax
0x100000f1d:  addq   $8, %rsp
0x100000f21:  popq   %rbx
0x100000f22:  popq   %r14
0x100000f24:  popq   %r15
0x100000f26:  popq   %rbp
0x100000f27:  ret  
```

Now all that's left is just to clean up.  First we clear `%eax`.  Why now?  Since it's the lower 32 bits of the first return register, we just clear it after returning from the last function call so that we can return 0 to **our** caller.  

Next we add 8 to the stack pointer.  This is an interesting development.  Why do we manually adjust the stack pointer?  Take a look at the function setup.  Initially we pushed the following registers: `%rbp`, `%r15`, `%r14`, `%rbx` and `%rax`.  But if we pop `%rax` which is our 1st function return value register, then we risk blowing away the effects of clearing `%eax` that we just did in `0x100000f1b:  xorl   %eax, %eax`, right?  So instead of popping the value, we manually adjust the stack pointer before popping the other variables in the reverse order to that in which we pushed them to the stack.

Lastly, we return to the caller.

Again, we close another chapter in our x86\_64 assembly tutorial for Mac.  We will continue to build on our knowledge base with slightly more complex tutorials as we progress; so stay tuned.  Here are some interesting and useful references for you:

- [x86\_64 ABI reference](http://www.x86-64.org/documentation/abi.pdf)
- [x86 assembly guide](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)
- [GNU assembler directives](http://cs.mtu.edu/~mmkoksal/blog/?x=entry:entry120116-130037)
- [x86 assembly idioms](http://stackoverflow.com/questions/2647640/x86-assembly-idioms)

And of course, [Part I](http://cocoafactory.com/blog/2012/11/23/x86-64-assembly-language-tutorial-part-1/) or our tutorial.

Question? Comments?  Tweet Alan `@NSBum`.

